# Custom-CPU-design
This project implements a fully functional 32-bit general-purpose CPU using VHDL in Quartus II, developed in three structured phases. The design begins with Lab 4, where the core CPU data-path is assembled by integrating pre-built modules including the Program Counter (PC), Instruction Register (IR), Registers A and B, ALU, Data Memory, Zero Extenders (LZE, UZE), and a series of 2-to-1 and 3-to-1 multiplexers. The data-path supports a 3-stage multi-cycle execution model (T0, T1, T2), with clock domains separated for the processor (Clk) and memory (mClk, operating at twice the frequency). All instructions flow through a consistent three-cycle pattern, with values latched into the IR via the DATA_IN input since instruction memory is implemented later in Lab 6. Memory operations such as LDA, STA, and immediate instructions like ADDI, ORI, LUI are enabled through structured use of the zero extenders and mux-controlled data flow. In Lab 5, the control unit is developed and attached to the data-path. This unit consists of three internal VHDL processes: a sequential state generator managing the instruction pipeline stages (T0â€“T2), a combinational operation decoder which sets control signals based on the opcode and function code (INST[31:28], INST[27:24]), and a memory signal generator that synchronizes wen and en signals during memory transactions to meet setup and hold constraints. The control unit uses internal flags such as Zero and Carry from the ALU to support conditional logic operations. Lab 6 completes the CPU by adding a synchronous reset circuit that initializes the system into a stable state. Upon RESET, the control unit is forced into state T0, ENABLE_PD is deasserted to freeze pipeline activity, and CLR_PC clears the Program Counter. These conditions persist for four clock cycles after reset to allow proper hardware stabilization. A MegaCore RAM block is instantiated to serve as the instruction memory, loaded via a .mif file, and connected to the data-path. The final CPU includes all subsystems: the data-path, control unit, reset logic, and instruction memory, all tied together in a top-level module. A complete testbench is used to simulate instruction sequences, verify control signal timing, and validate expected output on registers and memory. Supported instructions include arithmetic (ADD, SUB, ADDI), logical (AND, OR, ORI), data transfer (LDA, LDB, STA, STB, LUI, LDAI, LDBI), and address-based memory operations. Each instruction is handled over three cycles, with shared T0/T1 behavior and instruction-specific T2 logic. The design is modular, synthesizable, and extensible for future features such as branching, multiplication, or pipeline implementation. Optional bonus work includes deploying the CPU on physical FPGA hardware for live instruction emulation and verification.
